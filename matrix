#include <iostream>
#include <array>
using namespace std;

//python -c "import numpy as np;a=1+2j;b=2+3j;print a*b;"  (-4+7j)

template <typename T=float>
using ComplexT = array<T,2>;

using Complex = array<float,2>;

template <typename T,size_t M ,size_t N>
using Matrix = array<array<T,N>,M>;

ostream& operator<<(ostream& o,const Complex& elem) {
        return o<<elem[0]<<"+j"<<elem[1];
}

template <typename T>
using is_arith = typename std::enable_if<is_arithmetic<T>::value>::type;

template <typename T, typename = is_arith<T>>
//(a+bi)(c+di)=(ac-bd)+(bc+ad)i
inline array<T,2> complexMul(array<T,2> Z1,array<T,2> Z2){
    return {Z1[0]*Z2[0]-Z1[1]*Z2[1],Z1[1]*Z2[0]+Z1[0]*Z2[1]};
}

int main()
{
  Matrix<Complex,1,3> arrA = {{
	  {{{1,2},{2,3},{3,4}}}
  }};	
  Matrix<Complex,3,4> arrB = {{
	  {{{1,2},{2,3},{3,4},{4,5}}},
	  {{{1,2},{2,3},{3,4},{4,5}}},
	  {{{1,2},{2,3},{3,4},{4,5}}},
  }};	
  
  int M = 1;
  int N = 3;
  int L = 4;
  array<array<array<float,2>,1>,4> arrC;
  for(int i=0;i<M;i++){
    for(int j=0;j<L;j++){
      for(int k=0;k<N;k++){
        //arrC[i][j] += complexMul(arrA[i][k],arrB[k][j]);        
      }
    }
  
  }
   
  Complex z1 = {1,2};
  Complex z2 = {2,3};
 // auto res = complexMul('a','b');
  //cout << res;

  ComplexT<> bb;

  return 0;
}
