#include <iostream>
#include <array>
using namespace std;

template<class T>
class MatrixElem{
public:
        MatrixElem():real_(0),imag_(0){}
        MatrixElem(T r,T i):real_(r),imag_(i){}
        void operator()(MatrixElem<T>&& that){
                T r = real_*that.real_ - imag_*that.imag_ ;
                T i = imag_*that.real_ + real_*that.imag_;
                real_ = r;
                imag_ = i;
        }



friend ostream& operator<<(ostream& o,const MatrixElem& elem) {
        return o<<elem.real_<<"+j"<<elem.imag_;
}
private:
        T real_;
        T imag_;
};


template<class T>
class Matrix{
public:
        Matrix(){};
        Matrix(array<array<T>>&& t):mxv_(std::move(t)){};
        int getM(){return mxv_.size();}
        int getN(){return mxv_.size()==0?0:mxv_[0].size();}
        void operator()(Matrix<T>&& that){
                for(int i=0;i<getM();i++){
                        for(int j=0;j<getN();j++){
                                for(int k=0;k< that.getN();k++)
                                {
                                         mxv_[i][j](std::move(that.mxv_[j][k]));
                                }
                        }

                }
        }
friend ostream& operator<<(ostream& o, Matrix& mx) {
        o<<"m:"<< mx.getM() <<",n:"<< mx.getN() << ":" << endl;
        for(int i=0;i<mx.getM();i++){
                o<< "i:" << i ;
                for(int j=0;j<mx.getN();j++){
                        o << " " << mx.mxv_[i][j] ;
                }
                o<<endl;
        }
        return o;

}
private:
    array<array<T>> mxv_;
};

int main()
{

  MatrixElem<float> a(1.2,3.4);
  MatrixElem<float> b(1.3,3.5);
  cout << a << endl;
  cout << b << endl;
  a(std::move(b));
  cout << a << endl;


  array<array<MatrixElem<float,32>,1>> arr2_temp;
  for(int i=0;i<32;i++)
  {
     MatrixElem<float> m(i+0.1,i+1+0.2);
     arr2_temp[0][i] = m;
  }
  Matrix<MatrixElem<float>> m1(std::move(arr2_temp));






 // array<array<float>> vf = {{1}};

}
